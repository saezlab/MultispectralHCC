---
title: "cores"
author: "Jovan Tanevski"
date: "`r Sys.Date()`"
output: 
  workflowr::wflow_html:
    df_print: kable
editor_options:
  chunk_output_type: console
---

## Setup

```{r setup, message = FALSE}
library(tidyverse)
library(skimr)
library(uwot)
library(limma)
library(NMF)
library(factoextra)
library(cowplot)
```

```{r}
tumor.hc <- read_csv("data/tumor_hepatocytes.csv", col_types = cols()) %>%
  select(
    `Cytoplasm AGS (Opal 690) Mean (Normalized Counts, Total Weighting)`,
    `Cytoplasm BerEP4 (Opal 650) Mean (Normalized Counts, Total Weighting)`,
    `Cytoplasm CRP (Opal 540) Mean (Normalized Counts, Total Weighting)`,
    `Nucleus p-S6 (Opal 570) Mean (Normalized Counts, Total Weighting)`,
    `Nucleus beta-cat. (Opal 520) Mean (Normalized Counts, Total Weighting)`
  ) %>%
  `colnames<-`(str_split(colnames(.), " ") %>% map_chr(~ .x[2]) %>% make.names())

skim(tumor.hc)
```

Detect outliers based on Tukey's interquartile approach and winsorize. Follow by quantile normalization and ranking to get rid of the effect of abundance

```{r}
quartiles <- apply(tumor.hc, 2, \(x) quantile(x, c(.25, .75)))
lower <- quartiles[1, ] - 1.5 * (quartiles[2, ] - quartiles[1, ])
upper <- quartiles[2, ] + 1.5 * (quartiles[2, ] - quartiles[1, ])


tumor.hc.winsorized <- tumor.hc %>% imap_dfc(\(x, y){
  x[x < lower[y]] <- x[which.min(x - lower[y])]
  x[x > upper[y]] <- x[which.min(x - upper[y])]
  x
})

skim(tumor.hc.winsorized)

tumor.hc.norm <- normalizeQuantiles(data.frame(tumor.hc.winsorized))

skim(tumor.hc.norm)

tumor.hc.rank <- mutate_all(tumor.hc.winsorized, ~ rank(., ties.method = "min"))
```

Pilot run. Subsample 10% of the original data.

```{r}
set.seed(42)
percent <- 10
subsamp <- sample(nrow(tumor.hc.rank), (percent / 100) * nrow(tumor.hc.rank))
```


## Dimensionality reduction

```{r}
cache <- "output/tumor.hc.umap.rds"
if(file.exists(cache)){ 
  tumor.hc.umap <- read_rds(cache)
} else {
  tumor.hc.umap <- umap(tumor.hc.norm, n_threads = 5)
  write_rds(tumor.hc.umap, cache, "gz")
}
```

Check if sample is representative in UMAP space

```{r}
tumor.hc.umap.sample <-
  tumor.hc.umap %>%
  `colnames<-`(c("U1", "U2")) %>%
  as_tibble()

all <- ggplot(tumor.hc.umap.sample, aes(x = U1, y = U2)) +
  geom_point() +
  theme_classic()

sampled <- ggplot(tumor.hc.umap.sample %>% slice(subsamp), aes(x = U1, y = U2)) +
  geom_point(color = "darkgreen") +
  theme_classic()

unsampled <- ggplot(tumor.hc.umap.sample %>% slice(-subsamp), aes(x = U1, y = U2)) +
  geom_point(color = "darkred") +
  theme_classic()

plot_grid(all, sampled, unsampled)
```


## Consensus NMF

We use an efficient implementation of alternating non negative least-squares with regularized to favor sparse coefficient matrices snmf/r. In this way we aim for cleaner clustering.

```{r}
cache <- paste0("output/tumor.hc.nmf.rank.", percent, ".rds")

if (file.exists(cache)) {
  tumor.hc.nmf.rank <- read_rds(cache)
} else {
  tumor.hc.nmf.rank <- nmfEstimateRank(as.matrix(t(tumor.hc.rank[subsamp, ])),
    range = seq(2, 6), method = "snmf/r",
    nrun = 10, seed = 42, verbose = TRUE,
    .options = "mp5"
  )
  write_rds(tumor.hc.nmf.rank, cache, "gz")
}

plot(tumor.hc.nmf.rank)

tumor.hc.nmf <- tumor.hc.nmf.rank$fit[["3"]]
rm(tumor.hc.nmf.rank)
```

Extract basis of NMF (signature of cluster)

```{r}
basismap(tumor.hc.nmf)
```

Extract coefficients of NMF (soft clustering of samples) if a reasonable amount of cells is subselected.

```{r}
if (percent <= 2) coefmap(tumor.hc.nmf)
```

Assign clusters
```{r}
nmf.clusters <- apply(tumor.hc.nmf@fit@H, 2, which.max)
```

Plot in 2D PCA and UMAP

```{r}
tumor.hc.umap.clus <-
  tumor.hc.umap.sample %>%
  slice(subsamp) %>%
  mutate(Cluster = as.factor(nmf.clusters))

ggplot(tumor.hc.umap.clus, aes(x = U1, y = U2, color = Cluster)) +
  geom_point() +
  theme_classic()
```

Expression profiles per cluster 

```{r fig.width=10, fig.height=10}
tumor.hc.clustered.nmf <- tumor.hc.norm[subsamp, ] %>%
  mutate(Cluster = as.factor(nmf.clusters)) %>%
  pivot_longer(names_to = "Marker", values_to = "Norm.value", -Cluster)

profiles <- seq_len(max(nmf.clusters)) %>% map(~
ggplot(
  tumor.hc.clustered.nmf %>% filter(Cluster == .x),
  aes(x = Marker, y = Norm.value, color = Marker)
) +
  stat_summary(fun.data = mean_sdl, show.legend = FALSE) +
  ylim(-3, 3) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)))

plot_grid(plotlist = profiles, labels = paste("Cluster", seq_len(max(nmf.clusters))))
```


Differential expression analysis (silhouette)

Calculate the similarity of samples using the expression and the silhouette scores based on the assigned clusters.
```{r}
silhouette.nmf <- silhouette(nmf.clusters, dist(tumor.hc.norm[subsamp, ]))
fviz_silhouette(silhouette.nmf)
```

Select only the samples with positive silhouette scores as "core samples"
```{r}
core.samples <- which(silhouette.nmf[, 3] > 0)
tumor.hc.core.samples <- tumor.hc.norm[subsamp, ] %>%
  add_column(Cluster = nmf.clusters) %>%
  slice(core.samples)
```

Calculate difference in means (mean(cluster) - mean(other)), one-vs-all t-test per marker and correct for FDR. Filter q <= 0.05

```{r}
unique(tumor.hc.core.samples$Cluster) %>%
  map_dfr(\(c){
    tumor.hc.core.samples %>%
      summarize(across(-Cluster, ~ t.test(.x ~ (Cluster == c))$p.value)) %>%
      pivot_longer(names_to = "Marker", values_to = "p", everything()) %>%
      mutate(Cluster = c, Difference = tumor.hc.core.samples %>%
        group_by(Cluster == c) %>%
        select(-Cluster) %>%
        group_split(.keep = FALSE) %>% map(colMeans) %>% reduce(`-`))
  }) %>%
  mutate(q = p.adjust(p, method = "fdr"), Difference = -Difference) %>%
  filter(q <= 0.05) %>%
  arrange(q)
```
